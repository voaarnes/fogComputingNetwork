//
<<<<<<< HEAD
// Generated file, do not edit! Created by nedtool 5.7 from computerMessage.msg.
=======
// Generated file, do not edit! Created by opp_msgtool 6.0 from computerMessage.msg.
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
//

// Disable warnings about unused variables, empty switch stmts, etc:
#ifdef _MSC_VER
#  pragma warning(disable:4101)
#  pragma warning(disable:4065)
#endif

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wshadow"
#  pragma clang diagnostic ignored "-Wconversion"
#  pragma clang diagnostic ignored "-Wunused-parameter"
#  pragma clang diagnostic ignored "-Wc++98-compat"
#  pragma clang diagnostic ignored "-Wunreachable-code-break"
#  pragma clang diagnostic ignored "-Wold-style-cast"
#elif defined(__GNUC__)
#  pragma GCC diagnostic ignored "-Wshadow"
#  pragma GCC diagnostic ignored "-Wconversion"
#  pragma GCC diagnostic ignored "-Wunused-parameter"
#  pragma GCC diagnostic ignored "-Wold-style-cast"
#  pragma GCC diagnostic ignored "-Wsuggest-attribute=noreturn"
#  pragma GCC diagnostic ignored "-Wfloat-conversion"
#endif

#include <iostream>
#include <sstream>
<<<<<<< HEAD
=======
#include <memory>
#include <type_traits>
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
#include "computerMessage_m.h"

namespace omnetpp {

// Template pack/unpack rules. They are declared *after* a1l type-specific pack functions for multiple reasons.
// They are in the omnetpp namespace, to allow them to be found by argument-dependent lookup via the cCommBuffer argument

// Packing/unpacking an std::vector
template<typename T, typename A>
void doParsimPacking(omnetpp::cCommBuffer *buffer, const std::vector<T,A>& v)
{
    int n = v.size();
    doParsimPacking(buffer, n);
    for (int i = 0; i < n; i++)
        doParsimPacking(buffer, v[i]);
}

template<typename T, typename A>
void doParsimUnpacking(omnetpp::cCommBuffer *buffer, std::vector<T,A>& v)
{
    int n;
    doParsimUnpacking(buffer, n);
    v.resize(n);
    for (int i = 0; i < n; i++)
        doParsimUnpacking(buffer, v[i]);
}

// Packing/unpacking an std::list
template<typename T, typename A>
void doParsimPacking(omnetpp::cCommBuffer *buffer, const std::list<T,A>& l)
{
    doParsimPacking(buffer, (int)l.size());
    for (typename std::list<T,A>::const_iterator it = l.begin(); it != l.end(); ++it)
        doParsimPacking(buffer, (T&)*it);
}

template<typename T, typename A>
void doParsimUnpacking(omnetpp::cCommBuffer *buffer, std::list<T,A>& l)
{
    int n;
    doParsimUnpacking(buffer, n);
<<<<<<< HEAD
    for (int i=0; i<n; i++) {
=======
    for (int i = 0; i < n; i++) {
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
        l.push_back(T());
        doParsimUnpacking(buffer, l.back());
    }
}

// Packing/unpacking an std::set
template<typename T, typename Tr, typename A>
void doParsimPacking(omnetpp::cCommBuffer *buffer, const std::set<T,Tr,A>& s)
{
    doParsimPacking(buffer, (int)s.size());
    for (typename std::set<T,Tr,A>::const_iterator it = s.begin(); it != s.end(); ++it)
        doParsimPacking(buffer, *it);
}

template<typename T, typename Tr, typename A>
void doParsimUnpacking(omnetpp::cCommBuffer *buffer, std::set<T,Tr,A>& s)
{
    int n;
    doParsimUnpacking(buffer, n);
<<<<<<< HEAD
    for (int i=0; i<n; i++) {
=======
    for (int i = 0; i < n; i++) {
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
        T x;
        doParsimUnpacking(buffer, x);
        s.insert(x);
    }
}

// Packing/unpacking an std::map
template<typename K, typename V, typename Tr, typename A>
void doParsimPacking(omnetpp::cCommBuffer *buffer, const std::map<K,V,Tr,A>& m)
{
    doParsimPacking(buffer, (int)m.size());
    for (typename std::map<K,V,Tr,A>::const_iterator it = m.begin(); it != m.end(); ++it) {
        doParsimPacking(buffer, it->first);
        doParsimPacking(buffer, it->second);
    }
}

template<typename K, typename V, typename Tr, typename A>
void doParsimUnpacking(omnetpp::cCommBuffer *buffer, std::map<K,V,Tr,A>& m)
{
    int n;
    doParsimUnpacking(buffer, n);
<<<<<<< HEAD
    for (int i=0; i<n; i++) {
=======
    for (int i = 0; i < n; i++) {
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
        K k; V v;
        doParsimUnpacking(buffer, k);
        doParsimUnpacking(buffer, v);
        m[k] = v;
    }
}

// Default pack/unpack function for arrays
template<typename T>
void doParsimArrayPacking(omnetpp::cCommBuffer *b, const T *t, int n)
{
    for (int i = 0; i < n; i++)
        doParsimPacking(b, t[i]);
}

template<typename T>
void doParsimArrayUnpacking(omnetpp::cCommBuffer *b, T *t, int n)
{
    for (int i = 0; i < n; i++)
        doParsimUnpacking(b, t[i]);
}

// Default rule to prevent compiler from choosing base class' doParsimPacking() function
template<typename T>
void doParsimPacking(omnetpp::cCommBuffer *, const T& t)
{
    throw omnetpp::cRuntimeError("Parsim error: No doParsimPacking() function for type %s", omnetpp::opp_typename(typeid(t)));
}

template<typename T>
void doParsimUnpacking(omnetpp::cCommBuffer *, T& t)
{
    throw omnetpp::cRuntimeError("Parsim error: No doParsimUnpacking() function for type %s", omnetpp::opp_typename(typeid(t)));
}

}  // namespace omnetpp

<<<<<<< HEAD

// forward
template<typename T, typename A>
std::ostream& operator<<(std::ostream& out, const std::vector<T,A>& vec);

// Template rule which fires if a struct or class doesn't have operator<<
template<typename T>
inline std::ostream& operator<<(std::ostream& out,const T&) {return out;}

// operator<< for std::vector<T>
template<typename T, typename A>
inline std::ostream& operator<<(std::ostream& out, const std::vector<T,A>& vec)
{
    out.put('{');
    for(typename std::vector<T,A>::const_iterator it = vec.begin(); it != vec.end(); ++it)
    {
        if (it != vec.begin()) {
            out.put(','); out.put(' ');
        }
        out << *it;
    }
    out.put('}');
    
    char buf[32];
    sprintf(buf, " (size=%u)", (unsigned int)vec.size());
    out.write(buf, strlen(buf));
    return out;
}

Register_Class(ComputerMessage)

ComputerMessage::ComputerMessage(const char *name, short kind) : ::omnetpp::cMessage(name,kind)
{
    this->seq = 0;
    this->type = 0;
    this->source = 0;
=======
Register_Class(ComputerMessage)

ComputerMessage::ComputerMessage(const char *name, short kind) : ::omnetpp::cMessage(name, kind)
{
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

ComputerMessage::ComputerMessage(const ComputerMessage& other) : ::omnetpp::cMessage(other)
{
    copy(other);
}

ComputerMessage::~ComputerMessage()
{
}

ComputerMessage& ComputerMessage::operator=(const ComputerMessage& other)
{
<<<<<<< HEAD
    if (this==&other) return *this;
=======
    if (this == &other) return *this;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
    ::omnetpp::cMessage::operator=(other);
    copy(other);
    return *this;
}

void ComputerMessage::copy(const ComputerMessage& other)
{
    this->seq = other.seq;
<<<<<<< HEAD
    this->type = other.type;
    this->source = other.source;
=======
    this->globalSeq = other.globalSeq;
    this->type = other.type;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

void ComputerMessage::parsimPack(omnetpp::cCommBuffer *b) const
{
    ::omnetpp::cMessage::parsimPack(b);
    doParsimPacking(b,this->seq);
<<<<<<< HEAD
    doParsimPacking(b,this->type);
    doParsimPacking(b,this->source);
=======
    doParsimPacking(b,this->globalSeq);
    doParsimPacking(b,this->type);
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

void ComputerMessage::parsimUnpack(omnetpp::cCommBuffer *b)
{
    ::omnetpp::cMessage::parsimUnpack(b);
    doParsimUnpacking(b,this->seq);
<<<<<<< HEAD
    doParsimUnpacking(b,this->type);
    doParsimUnpacking(b,this->source);
=======
    doParsimUnpacking(b,this->globalSeq);
    doParsimUnpacking(b,this->type);
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

int ComputerMessage::getSeq() const
{
    return this->seq;
}

void ComputerMessage::setSeq(int seq)
{
    this->seq = seq;
}

<<<<<<< HEAD
=======
int ComputerMessage::getGlobalSeq() const
{
    return this->globalSeq;
}

void ComputerMessage::setGlobalSeq(int globalSeq)
{
    this->globalSeq = globalSeq;
}

>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
int ComputerMessage::getType() const
{
    return this->type;
}

void ComputerMessage::setType(int type)
{
    this->type = type;
}

<<<<<<< HEAD
int ComputerMessage::getSource() const
{
    return this->source;
}

void ComputerMessage::setSource(int source)
{
    this->source = source;
}

class ComputerMessageDescriptor : public omnetpp::cClassDescriptor
{
  private:
    mutable const char **propertynames;
=======
class ComputerMessageDescriptor : public omnetpp::cClassDescriptor
{
  private:
    mutable const char **propertyNames;
    enum FieldConstants {
        FIELD_seq,
        FIELD_globalSeq,
        FIELD_type,
    };
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
  public:
    ComputerMessageDescriptor();
    virtual ~ComputerMessageDescriptor();

    virtual bool doesSupport(omnetpp::cObject *obj) const override;
    virtual const char **getPropertyNames() const override;
<<<<<<< HEAD
    virtual const char *getProperty(const char *propertyname) const override;
=======
    virtual const char *getProperty(const char *propertyName) const override;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
    virtual int getFieldCount() const override;
    virtual const char *getFieldName(int field) const override;
    virtual int findField(const char *fieldName) const override;
    virtual unsigned int getFieldTypeFlags(int field) const override;
    virtual const char *getFieldTypeString(int field) const override;
    virtual const char **getFieldPropertyNames(int field) const override;
<<<<<<< HEAD
    virtual const char *getFieldProperty(int field, const char *propertyname) const override;
    virtual int getFieldArraySize(void *object, int field) const override;

    virtual const char *getFieldDynamicTypeString(void *object, int field, int i) const override;
    virtual std::string getFieldValueAsString(void *object, int field, int i) const override;
    virtual bool setFieldValueAsString(void *object, int field, int i, const char *value) const override;

    virtual const char *getFieldStructName(int field) const override;
    virtual void *getFieldStructValuePointer(void *object, int field, int i) const override;
=======
    virtual const char *getFieldProperty(int field, const char *propertyName) const override;
    virtual int getFieldArraySize(omnetpp::any_ptr object, int field) const override;
    virtual void setFieldArraySize(omnetpp::any_ptr object, int field, int size) const override;

    virtual const char *getFieldDynamicTypeString(omnetpp::any_ptr object, int field, int i) const override;
    virtual std::string getFieldValueAsString(omnetpp::any_ptr object, int field, int i) const override;
    virtual void setFieldValueAsString(omnetpp::any_ptr object, int field, int i, const char *value) const override;
    virtual omnetpp::cValue getFieldValue(omnetpp::any_ptr object, int field, int i) const override;
    virtual void setFieldValue(omnetpp::any_ptr object, int field, int i, const omnetpp::cValue& value) const override;

    virtual const char *getFieldStructName(int field) const override;
    virtual omnetpp::any_ptr getFieldStructValuePointer(omnetpp::any_ptr object, int field, int i) const override;
    virtual void setFieldStructValuePointer(omnetpp::any_ptr object, int field, int i, omnetpp::any_ptr ptr) const override;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
};

Register_ClassDescriptor(ComputerMessageDescriptor)

<<<<<<< HEAD
ComputerMessageDescriptor::ComputerMessageDescriptor() : omnetpp::cClassDescriptor("ComputerMessage", "omnetpp::cMessage")
{
    propertynames = nullptr;
=======
ComputerMessageDescriptor::ComputerMessageDescriptor() : omnetpp::cClassDescriptor(omnetpp::opp_typename(typeid(ComputerMessage)), "omnetpp::cMessage")
{
    propertyNames = nullptr;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

ComputerMessageDescriptor::~ComputerMessageDescriptor()
{
<<<<<<< HEAD
    delete[] propertynames;
=======
    delete[] propertyNames;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

bool ComputerMessageDescriptor::doesSupport(omnetpp::cObject *obj) const
{
    return dynamic_cast<ComputerMessage *>(obj)!=nullptr;
}

const char **ComputerMessageDescriptor::getPropertyNames() const
{
<<<<<<< HEAD
    if (!propertynames) {
        static const char *names[] = {  nullptr };
        omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
        const char **basenames = basedesc ? basedesc->getPropertyNames() : nullptr;
        propertynames = mergeLists(basenames, names);
    }
    return propertynames;
}

const char *ComputerMessageDescriptor::getProperty(const char *propertyname) const
{
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    return basedesc ? basedesc->getProperty(propertyname) : nullptr;
=======
    if (!propertyNames) {
        static const char *names[] = {  nullptr };
        omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
        const char **baseNames = base ? base->getPropertyNames() : nullptr;
        propertyNames = mergeLists(baseNames, names);
    }
    return propertyNames;
}

const char *ComputerMessageDescriptor::getProperty(const char *propertyName) const
{
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    return base ? base->getProperty(propertyName) : nullptr;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

int ComputerMessageDescriptor::getFieldCount() const
{
<<<<<<< HEAD
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    return basedesc ? 3+basedesc->getFieldCount() : 3;
=======
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    return base ? 3+base->getFieldCount() : 3;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

unsigned int ComputerMessageDescriptor::getFieldTypeFlags(int field) const
{
<<<<<<< HEAD
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    if (basedesc) {
        if (field < basedesc->getFieldCount())
            return basedesc->getFieldTypeFlags(field);
        field -= basedesc->getFieldCount();
    }
    static unsigned int fieldTypeFlags[] = {
        FD_ISEDITABLE,
        FD_ISEDITABLE,
        FD_ISEDITABLE,
    };
    return (field>=0 && field<3) ? fieldTypeFlags[field] : 0;
=======
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount())
            return base->getFieldTypeFlags(field);
        field -= base->getFieldCount();
    }
    static unsigned int fieldTypeFlags[] = {
        FD_ISEDITABLE,    // FIELD_seq
        FD_ISEDITABLE,    // FIELD_globalSeq
        FD_ISEDITABLE,    // FIELD_type
    };
    return (field >= 0 && field < 3) ? fieldTypeFlags[field] : 0;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

const char *ComputerMessageDescriptor::getFieldName(int field) const
{
<<<<<<< HEAD
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    if (basedesc) {
        if (field < basedesc->getFieldCount())
            return basedesc->getFieldName(field);
        field -= basedesc->getFieldCount();
    }
    static const char *fieldNames[] = {
        "seq",
        "type",
        "source",
    };
    return (field>=0 && field<3) ? fieldNames[field] : nullptr;
=======
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount())
            return base->getFieldName(field);
        field -= base->getFieldCount();
    }
    static const char *fieldNames[] = {
        "seq",
        "globalSeq",
        "type",
    };
    return (field >= 0 && field < 3) ? fieldNames[field] : nullptr;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

int ComputerMessageDescriptor::findField(const char *fieldName) const
{
<<<<<<< HEAD
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    int base = basedesc ? basedesc->getFieldCount() : 0;
    if (fieldName[0]=='s' && strcmp(fieldName, "seq")==0) return base+0;
    if (fieldName[0]=='t' && strcmp(fieldName, "type")==0) return base+1;
    if (fieldName[0]=='s' && strcmp(fieldName, "source")==0) return base+2;
    return basedesc ? basedesc->findField(fieldName) : -1;
=======
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    int baseIndex = base ? base->getFieldCount() : 0;
    if (strcmp(fieldName, "seq") == 0) return baseIndex + 0;
    if (strcmp(fieldName, "globalSeq") == 0) return baseIndex + 1;
    if (strcmp(fieldName, "type") == 0) return baseIndex + 2;
    return base ? base->findField(fieldName) : -1;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

const char *ComputerMessageDescriptor::getFieldTypeString(int field) const
{
<<<<<<< HEAD
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    if (basedesc) {
        if (field < basedesc->getFieldCount())
            return basedesc->getFieldTypeString(field);
        field -= basedesc->getFieldCount();
    }
    static const char *fieldTypeStrings[] = {
        "int",
        "int",
        "int",
    };
    return (field>=0 && field<3) ? fieldTypeStrings[field] : nullptr;
=======
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount())
            return base->getFieldTypeString(field);
        field -= base->getFieldCount();
    }
    static const char *fieldTypeStrings[] = {
        "int",    // FIELD_seq
        "int",    // FIELD_globalSeq
        "int",    // FIELD_type
    };
    return (field >= 0 && field < 3) ? fieldTypeStrings[field] : nullptr;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
}

const char **ComputerMessageDescriptor::getFieldPropertyNames(int field) const
{
<<<<<<< HEAD
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    if (basedesc) {
        if (field < basedesc->getFieldCount())
            return basedesc->getFieldPropertyNames(field);
        field -= basedesc->getFieldCount();
=======
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount())
            return base->getFieldPropertyNames(field);
        field -= base->getFieldCount();
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
    }
    switch (field) {
        default: return nullptr;
    }
}

<<<<<<< HEAD
const char *ComputerMessageDescriptor::getFieldProperty(int field, const char *propertyname) const
{
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    if (basedesc) {
        if (field < basedesc->getFieldCount())
            return basedesc->getFieldProperty(field, propertyname);
        field -= basedesc->getFieldCount();
=======
const char *ComputerMessageDescriptor::getFieldProperty(int field, const char *propertyName) const
{
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount())
            return base->getFieldProperty(field, propertyName);
        field -= base->getFieldCount();
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
    }
    switch (field) {
        default: return nullptr;
    }
}

<<<<<<< HEAD
int ComputerMessageDescriptor::getFieldArraySize(void *object, int field) const
{
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    if (basedesc) {
        if (field < basedesc->getFieldCount())
            return basedesc->getFieldArraySize(object, field);
        field -= basedesc->getFieldCount();
    }
    ComputerMessage *pp = (ComputerMessage *)object; (void)pp;
=======
int ComputerMessageDescriptor::getFieldArraySize(omnetpp::any_ptr object, int field) const
{
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount())
            return base->getFieldArraySize(object, field);
        field -= base->getFieldCount();
    }
    ComputerMessage *pp = omnetpp::fromAnyPtr<ComputerMessage>(object); (void)pp;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
    switch (field) {
        default: return 0;
    }
}

<<<<<<< HEAD
const char *ComputerMessageDescriptor::getFieldDynamicTypeString(void *object, int field, int i) const
{
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    if (basedesc) {
        if (field < basedesc->getFieldCount())
            return basedesc->getFieldDynamicTypeString(object,field,i);
        field -= basedesc->getFieldCount();
    }
    ComputerMessage *pp = (ComputerMessage *)object; (void)pp;
=======
void ComputerMessageDescriptor::setFieldArraySize(omnetpp::any_ptr object, int field, int size) const
{
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount()){
            base->setFieldArraySize(object, field, size);
            return;
        }
        field -= base->getFieldCount();
    }
    ComputerMessage *pp = omnetpp::fromAnyPtr<ComputerMessage>(object); (void)pp;
    switch (field) {
        default: throw omnetpp::cRuntimeError("Cannot set array size of field %d of class 'ComputerMessage'", field);
    }
}

const char *ComputerMessageDescriptor::getFieldDynamicTypeString(omnetpp::any_ptr object, int field, int i) const
{
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount())
            return base->getFieldDynamicTypeString(object,field,i);
        field -= base->getFieldCount();
    }
    ComputerMessage *pp = omnetpp::fromAnyPtr<ComputerMessage>(object); (void)pp;
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
    switch (field) {
        default: return nullptr;
    }
}

<<<<<<< HEAD
std::string ComputerMessageDescriptor::getFieldValueAsString(void *object, int field, int i) const
{
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    if (basedesc) {
        if (field < basedesc->getFieldCount())
            return basedesc->getFieldValueAsString(object,field,i);
        field -= basedesc->getFieldCount();
    }
    ComputerMessage *pp = (ComputerMessage *)object; (void)pp;
    switch (field) {
        case 0: return long2string(pp->getSeq());
        case 1: return long2string(pp->getType());
        case 2: return long2string(pp->getSource());
=======
std::string ComputerMessageDescriptor::getFieldValueAsString(omnetpp::any_ptr object, int field, int i) const
{
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount())
            return base->getFieldValueAsString(object,field,i);
        field -= base->getFieldCount();
    }
    ComputerMessage *pp = omnetpp::fromAnyPtr<ComputerMessage>(object); (void)pp;
    switch (field) {
        case FIELD_seq: return long2string(pp->getSeq());
        case FIELD_globalSeq: return long2string(pp->getGlobalSeq());
        case FIELD_type: return long2string(pp->getType());
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
        default: return "";
    }
}

<<<<<<< HEAD
bool ComputerMessageDescriptor::setFieldValueAsString(void *object, int field, int i, const char *value) const
{
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    if (basedesc) {
        if (field < basedesc->getFieldCount())
            return basedesc->setFieldValueAsString(object,field,i,value);
        field -= basedesc->getFieldCount();
    }
    ComputerMessage *pp = (ComputerMessage *)object; (void)pp;
    switch (field) {
        case 0: pp->setSeq(string2long(value)); return true;
        case 1: pp->setType(string2long(value)); return true;
        case 2: pp->setSource(string2long(value)); return true;
        default: return false;
=======
void ComputerMessageDescriptor::setFieldValueAsString(omnetpp::any_ptr object, int field, int i, const char *value) const
{
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount()){
            base->setFieldValueAsString(object, field, i, value);
            return;
        }
        field -= base->getFieldCount();
    }
    ComputerMessage *pp = omnetpp::fromAnyPtr<ComputerMessage>(object); (void)pp;
    switch (field) {
        case FIELD_seq: pp->setSeq(string2long(value)); break;
        case FIELD_globalSeq: pp->setGlobalSeq(string2long(value)); break;
        case FIELD_type: pp->setType(string2long(value)); break;
        default: throw omnetpp::cRuntimeError("Cannot set field %d of class 'ComputerMessage'", field);
    }
}

omnetpp::cValue ComputerMessageDescriptor::getFieldValue(omnetpp::any_ptr object, int field, int i) const
{
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount())
            return base->getFieldValue(object,field,i);
        field -= base->getFieldCount();
    }
    ComputerMessage *pp = omnetpp::fromAnyPtr<ComputerMessage>(object); (void)pp;
    switch (field) {
        case FIELD_seq: return pp->getSeq();
        case FIELD_globalSeq: return pp->getGlobalSeq();
        case FIELD_type: return pp->getType();
        default: throw omnetpp::cRuntimeError("Cannot return field %d of class 'ComputerMessage' as cValue -- field index out of range?", field);
    }
}

void ComputerMessageDescriptor::setFieldValue(omnetpp::any_ptr object, int field, int i, const omnetpp::cValue& value) const
{
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount()){
            base->setFieldValue(object, field, i, value);
            return;
        }
        field -= base->getFieldCount();
    }
    ComputerMessage *pp = omnetpp::fromAnyPtr<ComputerMessage>(object); (void)pp;
    switch (field) {
        case FIELD_seq: pp->setSeq(omnetpp::checked_int_cast<int>(value.intValue())); break;
        case FIELD_globalSeq: pp->setGlobalSeq(omnetpp::checked_int_cast<int>(value.intValue())); break;
        case FIELD_type: pp->setType(omnetpp::checked_int_cast<int>(value.intValue())); break;
        default: throw omnetpp::cRuntimeError("Cannot set field %d of class 'ComputerMessage'", field);
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
    }
}

const char *ComputerMessageDescriptor::getFieldStructName(int field) const
{
<<<<<<< HEAD
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    if (basedesc) {
        if (field < basedesc->getFieldCount())
            return basedesc->getFieldStructName(field);
        field -= basedesc->getFieldCount();
=======
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount())
            return base->getFieldStructName(field);
        field -= base->getFieldCount();
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410
    }
    switch (field) {
        default: return nullptr;
    };
}

<<<<<<< HEAD
void *ComputerMessageDescriptor::getFieldStructValuePointer(void *object, int field, int i) const
{
    omnetpp::cClassDescriptor *basedesc = getBaseClassDescriptor();
    if (basedesc) {
        if (field < basedesc->getFieldCount())
            return basedesc->getFieldStructValuePointer(object, field, i);
        field -= basedesc->getFieldCount();
    }
    ComputerMessage *pp = (ComputerMessage *)object; (void)pp;
    switch (field) {
        default: return nullptr;
    }
}

=======
omnetpp::any_ptr ComputerMessageDescriptor::getFieldStructValuePointer(omnetpp::any_ptr object, int field, int i) const
{
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount())
            return base->getFieldStructValuePointer(object, field, i);
        field -= base->getFieldCount();
    }
    ComputerMessage *pp = omnetpp::fromAnyPtr<ComputerMessage>(object); (void)pp;
    switch (field) {
        default: return omnetpp::any_ptr(nullptr);
    }
}

void ComputerMessageDescriptor::setFieldStructValuePointer(omnetpp::any_ptr object, int field, int i, omnetpp::any_ptr ptr) const
{
    omnetpp::cClassDescriptor *base = getBaseClassDescriptor();
    if (base) {
        if (field < base->getFieldCount()){
            base->setFieldStructValuePointer(object, field, i, ptr);
            return;
        }
        field -= base->getFieldCount();
    }
    ComputerMessage *pp = omnetpp::fromAnyPtr<ComputerMessage>(object); (void)pp;
    switch (field) {
        default: throw omnetpp::cRuntimeError("Cannot set field %d of class 'ComputerMessage'", field);
    }
}

namespace omnetpp {

}  // namespace omnetpp
>>>>>>> 9d29ec1e972483d6574672af67a59bb7b0640410

